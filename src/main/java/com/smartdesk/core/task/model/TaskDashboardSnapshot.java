package com.smartdesk.core.task.model;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Immutable projection used by the UI to render the task dashboard. The
 * snapshot is generated by {@code TaskService} and groups tasks into logical
 * lanes for Today, Upcoming, Someday, etc.
 */
public final class TaskDashboardSnapshot {

    private final LocalDate referenceDate;
    private final Map<TaskLane, List<Task>> lanes;

    public TaskDashboardSnapshot(final LocalDate referenceDate,
                                 final Map<TaskLane, List<Task>> lanes) {
        this.referenceDate = Objects.requireNonNull(referenceDate, "referenceDate");
        final EnumMap<TaskLane, List<Task>> copy = new EnumMap<>(TaskLane.class);
        if (lanes != null) {
            lanes.forEach((lane, tasks) -> copy.put(lane,
                tasks == null ? List.of() : List.copyOf(tasks)));
        }
        this.lanes = Collections.unmodifiableMap(copy);
    }

    public LocalDate getReferenceDate() {
        return referenceDate;
    }

    public Map<TaskLane, List<Task>> getLanes() {
        return lanes;
    }

    public List<Task> getTasksInLane(final TaskLane lane) {
        return lanes.getOrDefault(lane, List.of());
    }

    /**
     * Converts the snapshot into a sequence of board columns carrying
     * presentation metadata for the UI å±‚.
     */
    public List<TaskBoardColumn> toBoardColumns() {
        final List<TaskBoardColumn> columns = new ArrayList<>();
        for (TaskLane lane : TaskLane.values()) {
            columns.add(TaskBoardColumn.fromLane(lane, getTasksInLane(lane)));
        }
        return List.copyOf(columns);
    }

    /**
     * Returns a single board column for the requested lane.
     */
    public TaskBoardColumn toBoardColumn(final TaskLane lane) {
        Objects.requireNonNull(lane, "lane");
        return TaskBoardColumn.fromLane(lane, getTasksInLane(lane));
    }
}
